# ğŸ“˜ Compiler Blueprint â€“ Programming Exercises

This repository contains chapter-wise programming exercises based on the *Compiler Blueprint* book. Each exercise is linked to its corresponding source file and focuses on core compiler construction concepts, from lexical analysis to code optimization.

ğŸŒ **Live Site:** [Compiler Learning Hub](https://compiler-learninghub.onrender.com)  
ğŸ“¥ **Download the book:** [Compiler Blueprint PDF](https://drive.google.com/file/d/1TRMY7GE4qbrQnGHrVyXrGyO641CmaTYF/view?usp=drive_link)

---

## ğŸ“– Chapters Covered

- âœ… Chapter 1: Introduction to Compilers  
- âœ… Chapter 2: Phases of a Compiler  
- âœ… Chapter 3: Lexical Analysis & Context-Free Grammar  
- âœ… Chapter 4: Regular Expressions  
- âœ… Chapter 5: Finite Automata â€“ NFA & DFA  
- âœ… Chapter 6: Left Recursion & Left Factoring  
- âœ… Chapter 8: LR(0) Parser and Canonical Table  
- âœ… Chapter 11: Basic Blocks and Flow Graph  
- âœ… Chapter 12: Code Optimization  

---

## ğŸ§© Chapter 1 â€“ Introduction to Compilers

- [P_1.1](p_1.1.c): Count the number of vowels in a string  
- [P_1.2](p_1.2.c): Convert lowercase letters to uppercase  
- [P_1.3](p_1.3.c): Reverse a string without using library functions  
- [P_1.4](p_1.4.c): Count the number of words in a sentence  
- [P_1.5](p_1.5.c): Check whether a string is a palindrome  

---

## âš™ï¸ Chapter 2 â€“ Phases of a Compiler

- [PP_2.1](p_2.1.c): Tokenize a line of code  
- [PP_2.2](p_2.2.c): Build a symbol table from variable declarations  
- [PP_2.3](p_2.3.c): Convert infix expression to 3-address code  
- [PP_2.4](p_2.4.c): Detect type mismatch in assignments  

---

## ğŸ” Chapter 3 â€“ Lexical Analysis & CFG

- [PP_3.1](p_3.1.py): Extract identifiers using regular expressions  
- [PP_3.2](p_3.2.py): Lexical analyzer for arithmetic expressions  
- [PP_3.3](p_3.3.py): DFA for binary numbers divisible by 3  
- [PP_3.4](p_3.4.c): Tokenize C-style source and count keywords/identifiers  
- [PP_3.5](p_3.5.py): Parse strings using CFG with `nltk` or `lark`  
- [PP_3.6](p_3.6.py): CYK parser for CFG string acceptance  
- [PP_3.7](p_3.7.py): Convert CFG to left-factored form  
- [PP_3.8](p_3.8.py): Simulate CFG derivations and print parse tree  

---

## ğŸ”¡ Chapter 4 â€“ Regular Expressions

- [PP_4.1](p_4.1.c): Check if a string is binary (0|1)*  
- [PP_4.2](p_4.2.c): Accept strings with even number of 'a' characters  
- [PP_4.3](p_4.3.c): Match pattern a*b*c*  
- [PP_4.4](p_4.4.c): Validate C identifiers  
- [PP_4.5](p_4.5.c): Check for even-length palindromes  
- [PP_4.6](p_4.6.c): Accept alternating 'a' and 'b' strings starting with 'a'  

---

## ğŸ” Chapter 5 â€“ Finite Automata (DFA & NFA)

- [PP_5.1](p_5.1.cpp): DFA for binary numbers divisible by 3  
- [PP_5.2](p_5.2.cpp): DFA for strings ending in "01"  
- [PP_5.3](p_5.3.cpp): DFA for even number of 0s  
- [PP_5.4](p_5.4.cpp): DFA string acceptance via transition table  
- [PP_5.5](p_5.5.cpp): NFA for regular expression ab*  
- [PP_5.6](p_5.6.cpp): Îµ-NFA for strings ending with 'a' or 'aa'  
- [PP_5.7](p_5.7.cpp): Convert NFA to DFA using transition table  

---

## ğŸ§® Chapter 6 â€“ Left Recursion & Left Factoring

- [PP_6.1](p_6.1.c): Detect immediate left recursion  
- [PP_6.2](p_6.2.c): Eliminate immediate left recursion  
- [PP_6.3](p_6.3.c): Factor out common prefixes in productions  
- [PP_6.4](p_6.4.c): Perform left factoring on two alternatives  

---

## ğŸ“Š Chapter 8 â€“ LR(0) Parsing

- [PP_8.1](p_8.1.cpp): Generate LR(0) items from CFG  
- [PP_8.2](p_8.2.cpp): Canonical collection using closures and GOTO  
- [PP_8.3](p_8.3.cpp): Build parsing table and simulate shift/reduce parsing  

---

## ğŸ” Chapter 11 â€“ Basic Blocks & Flow Graphs

- [PP_11.1](p_11.1.cpp): Identify leaders in code  
- [PP_11.2](p_11.2.cpp): Generate control flow graph  

---

## ğŸ§  Chapter 12 â€“ Code Optimization

- [PP_12.1](p_12.1.cpp): Perform constant folding  
- [PP_12.2](p_12.2.cpp): Detect dead code in assignments  
- [PP_12.3](p_12.3.cpp): Implement copy propagation  

---

Feel free to contribute, improve, or extend these exercises. Happy compiling! ğŸš€
