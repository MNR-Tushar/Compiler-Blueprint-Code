# 📘 Compiler Blueprint – Programming Exercises

This repository contains chapter-wise programming exercises based on the *Compiler Blueprint* book. Each exercise is linked to its corresponding source file and focuses on core compiler construction concepts, from lexical analysis to code optimization.

🌐 **Live Site:** [Compiler Learning Hub](https://compiler-learninghub.onrender.com)  
📥 **Download the book:** [Compiler Blueprint PDF](https://drive.google.com/file/d/1TRMY7GE4qbrQnGHrVyXrGyO641CmaTYF/view?usp=drive_link)

---

## 📖 Chapters Covered

- ✅ Chapter 1: Introduction to Compilers  
- ✅ Chapter 2: Phases of a Compiler  
- ✅ Chapter 3: Lexical Analysis & Context-Free Grammar  
- ✅ Chapter 4: Regular Expressions  
- ✅ Chapter 5: Finite Automata – NFA & DFA  
- ✅ Chapter 6: Left Recursion & Left Factoring  
- ✅ Chapter 8: LR(0) Parser and Canonical Table  
- ✅ Chapter 11: Basic Blocks and Flow Graph  
- ✅ Chapter 12: Code Optimization  

---

## 🧩 Chapter 1 – Introduction to Compilers

- [P_1.1](p_1.1.c): Count the number of vowels in a string  
- [P_1.2](p_1.2.c): Convert lowercase letters to uppercase  
- [P_1.3](p_1.3.c): Reverse a string without using library functions  
- [P_1.4](p_1.4.c): Count the number of words in a sentence  
- [P_1.5](p_1.5.c): Check whether a string is a palindrome  

---

## ⚙️ Chapter 2 – Phases of a Compiler

- [PP_2.1](p_2.1.c): Tokenize a line of code  
- [PP_2.2](p_2.2.c): Build a symbol table from variable declarations  
- [PP_2.3](p_2.3.c): Convert infix expression to 3-address code  
- [PP_2.4](p_2.4.c): Detect type mismatch in assignments  

---

## 🔍 Chapter 3 – Lexical Analysis & CFG

- [PP_3.1](p_3.1.py): Extract identifiers using regular expressions  
- [PP_3.2](p_3.2.py): Lexical analyzer for arithmetic expressions  
- [PP_3.3](p_3.3.py): DFA for binary numbers divisible by 3  
- [PP_3.4](p_3.4.c): Tokenize C-style source and count keywords/identifiers  
- [PP_3.5](p_3.5.py): Parse strings using CFG with `nltk` or `lark`  
- [PP_3.6](p_3.6.py): CYK parser for CFG string acceptance  
- [PP_3.7](p_3.7.py): Convert CFG to left-factored form  
- [PP_3.8](p_3.8.py): Simulate CFG derivations and print parse tree  

---

## 🔡 Chapter 4 – Regular Expressions

- [PP_4.1](p_4.1.c): Check if a string is binary (0|1)*  
- [PP_4.2](p_4.2.c): Accept strings with even number of 'a' characters  
- [PP_4.3](p_4.3.c): Match pattern a*b*c*  
- [PP_4.4](p_4.4.c): Validate C identifiers  
- [PP_4.5](p_4.5.c): Check for even-length palindromes  
- [PP_4.6](p_4.6.c): Accept alternating 'a' and 'b' strings starting with 'a'  

---

## 🔁 Chapter 5 – Finite Automata (DFA & NFA)

- [PP_5.1](p_5.1.cpp): DFA for binary numbers divisible by 3  
- [PP_5.2](p_5.2.cpp): DFA for strings ending in "01"  
- [PP_5.3](p_5.3.cpp): DFA for even number of 0s  
- [PP_5.4](p_5.4.cpp): DFA string acceptance via transition table  
- [PP_5.5](p_5.5.cpp): NFA for regular expression ab*  
- [PP_5.6](p_5.6.cpp): ε-NFA for strings ending with 'a' or 'aa'  
- [PP_5.7](p_5.7.cpp): Convert NFA to DFA using transition table  

---

## 🧮 Chapter 6 – Left Recursion & Left Factoring

- [PP_6.1](p_6.1.c): Detect immediate left recursion  
- [PP_6.2](p_6.2.c): Eliminate immediate left recursion  
- [PP_6.3](p_6.3.c): Factor out common prefixes in productions  
- [PP_6.4](p_6.4.c): Perform left factoring on two alternatives  

---

## 📊 Chapter 8 – LR(0) Parsing

- [PP_8.1](p_8.1.cpp): Generate LR(0) items from CFG  
- [PP_8.2](p_8.2.cpp): Canonical collection using closures and GOTO  
- [PP_8.3](p_8.3.cpp): Build parsing table and simulate shift/reduce parsing  

---

## 🔁 Chapter 11 – Basic Blocks & Flow Graphs

- [PP_11.1](p_11.1.cpp): Identify leaders in code  
- [PP_11.2](p_11.2.cpp): Generate control flow graph  

---

## 🧠 Chapter 12 – Code Optimization

- [PP_12.1](p_12.1.cpp): Perform constant folding  
- [PP_12.2](p_12.2.cpp): Detect dead code in assignments  
- [PP_12.3](p_12.3.cpp): Implement copy propagation  

---

Feel free to contribute, improve, or extend these exercises. Happy compiling! 🚀
